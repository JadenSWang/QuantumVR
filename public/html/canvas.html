<!-- Canvas... Whoop!!! -->
<p>
	<span class="mainCanvas"><canvas></canvas></span>
</p>

<script>
	var camera, scene, renderer;
	var geometry, material;
	var array;

	init();
	animate();

	function init() {

		const canvas = document.querySelector('canvas');
		canvas.width = innerWidth;
		canvas.height = innerHeight;
		const renderer = new THREE.WebGLRenderer({ canvas });

		const fov = 75;
		const aspect = innerWidth / innerHeight;  // the canvas default
		const near = 0.1;
		const far = 5;
		const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
		camera.position.z = 1.5;

		const scene = new THREE.Scene();

		{
			const color = 0xFFffFF;
			const intensity = 1;
			const light = new THREE.DirectionalLight(color, intensity);
			light.position.set(-1, 2, 4);
			scene.add(light);
		}

		const boxWidth = 0.2;
		const boxHeight = 2;
		const boxDepth = 0.2;
		const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

		function makeInstance(geometry, color, x) {
			const material = new THREE.MeshPhongMaterial({ color });

			const cube = new THREE.Mesh(geometry, material);
			scene.add(cube);

			cube.position.x = x;

			return cube;
		}

		const cubes = [
			makeInstance(geometry, 0x44aa88, 0),
			makeInstance(geometry, 0x8844aa, 0),
			makeInstance(geometry, 0xaa8844, 0),
		];
		function render(time) {
			time *= 0.0025;  // convert time to seconds

			cubes.forEach((cube, ndx) => {
				const speed = 1 + ndx * .1;
				const rot = time * speed;
				cube.rotation.x = rot;
				cube.rotation.y = 1.3 * rot;
				cube.rotation.z = 1.8 * rot;

			});

			renderer.render(scene, camera);

			requestAnimationFrame(render);
		}
		requestAnimationFrame(render);
	}
</script>


<style>
	html {
		overflow-y: hidden;
		overflow-x: hidden;
	}

	.mainCanvas canvas {
		margin-top: -0.5%;
		margin-left: 3%;
		width: 94%;
	}
</style>